不是严格的继承谱系下产生的循环引用问题
对象 a 和 b 互相持有对方的强引用，形成了循环引用。因此，当程序退出时，它们的引用计数永远不会降为零，导致它们的内存无法正常释放，从而产生内存泄漏。
如果是严格的继承谱系,从父节点到子节点的链接可以使用std::unique_ptr,子节点到父节点的反向链接也可以使用裸指针进行安全的实现(父节点生存期更长,不会出现空悬指针)
```cpp
class A {
public:
    std::shared_ptr<B> b_ptr;
};

class B {
public:
    std::shared_ptr<A> a_ptr;
};

int main() {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();

    // 形成循环引用
    a->b_ptr = b;
    b->a_ptr = a;

    return 0;
}
```

std::weak_ptr可以检测是否空悬
```cpp
#include <memory>
#include <iostream>
class Entity{
};

int main(){
    auto spw = std::make_shared<Entity>();
    std::weak_ptr<Entity> wpw(spw);

    spw = nullptr;

    if(wpw.expired()){
        std::cout << "对象已经被析构" << std::endl;
    }
}
```
std::weak_ptr可以检测是否空悬,如果尚未失效就访问它所指涉的对象
难点: weak_ptr 没有提领操作. 如果检验和提领分离可能会在这两者之间该shared_ptr被析构或者重新赋值

```cpp
    //方法一
    auto spw2 = wpw.lock(); // spw2 类型是 std::shared_ptr<Entity>
    //方法二
    std::shared_ptr<Entity> spw3(wpw);
```
